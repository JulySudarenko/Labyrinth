Lesson 1
1. Спроектировать и создать уровень
/выполнено
2. Создать основные классы и обернуть их в пространство имен. Подготовить диаграмму классов
/выполнено
3. *Разработать игрока с альтернативным управлением
/выполнено
/переделала управление через наследование, чтобы было два варианта управления одновременно.

Lesson 2
1.	Расписать в текстовом документе, зачем нужны интерфейсы и их отличие от классов
Интерфейсы нужны для:
1.	реализации множественного наследования
2.	определения поведения в классах наследниках
Отличие интерфейсов от классов:
		Интерфейс							|		Класс
		
Все члены интерфейсов неявно абстрактные 	|	Члены могут быть как абстрактными, так и конкретные с реализацией
Начиная с C# 8.0 реализация методов 		|
 и свойств поддерживается по умолчанию		|

Можно реализовать несколько интерфейсов		|	Может быть унаследован только от одного класса

Члены класса неявно public					|	Члены класса могут быть определены как public, private или protected

Неявно реализованный член интерфейса 		|	Чтобы метод стал запечатанным класс 
по умолчанию является запечатанным			|	должен быть sealed или метод надо пометить как sealed

2.	Расписать в текстовом документе, зачем нужны обобщение и привести несколько примеров их использования
Обобщение - такой способ описания данных и алгоритмов, который позволяет использовать их с различными типами данных.
Обобщения в сравнении с наследованием позволяют повысить безопасность данных, а также сократить количество приведений.
с помощью обощенных методов несколько методов могут быть реализованы одним универсальным способом.
public class Templates<T>
{
    public T _id {get; set; }

    public T GetTemplate()
    {
        return default(T);
    }

    public void AllPrint (T obj)
    {
        Debug.Log(obj);
    }
}
public class FirstLessonExamples : MonoBehaviour
    {
        private void Start()
        {
            var TemplateClassFirst = new Templates<int>();
            var TemplateClassSecond = new Templates<string>();

            TemplateClassFirst.AllPrint(3);
            TemplateClassSecond.AllPrint("test");

            int x = 2;
            int y = 3;

            float a = 1.2f;
            float b = 1.8f;

            Swap<int>(ref x, ref y);
            Swap<float>(ref a, ref b);
        }
        public static void Swap<T>(ref T x, ref T y)
        {
            T t = x;
            T z = y;
            Debug.Log(t);
            Debug.Log(z);
        }
    }
Примеры приложены картинками.

3.	Добавить в игру положительные бонусы, которые необходимо обязательно собрать для победы
/добавила
4.	Добавить в игру положительные бонусы, которые дают различные улучшения (временный прирост скорости, неуязвимость и т.д.)
/добавила
5.	Добавить в игру различные ловушки (моментальная смерть, замедление и т.д.)
/добавила
6.	Реализовать статический импорт класса Debug, где это необходимо
/выполнено
7.	* Реализовать интерфейс ICloneable для клонирование game object
/не делала
8.	* Реализовать интерфейс IDisposable для игрока, ловушек и бонусов
/не делала

Lesson 3
1. По условию, где программа может вести себя неправильно, из-за ошибки гейм и левл дизайнеров, пробросить исключение.
/добавила
2. Расписать в текстовом документе зачем нужно отлавливать исключения и привести примеры.
Исключения нужны, чтобы сообщить геймдизайнеру или программисту о возникновении ошибки в программе, не останавливая ее работу.

Попытка записи в файл, доступный только для чтения
if (!this.logFile.CanWrite)
{
    throw new System.InvalidOperationException("Logfile cannot be read-only");
}

Проверка на ноль
if (Player == null)
{
    throw new NullReferenceException($"Player not found");
}

3. Добавить событие для подбора бонусов и ловушек и подписать нескольких слушателей на это событие, например потряхивать камеру.
/Сделала через Dictionary
4. *Задание из пункта 1, только использовать свое исключение
/готово
5. *Задание из пункта 3, только использовать свое событие
/не делала