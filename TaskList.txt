Lesson 1
1. Спроектировать и создать уровень
/выполнено
2. Создать основные классы и обернуть их в пространство имен. Подготовить диаграмму классов
/выполнено
3. *Разработать игрока с альтернативным управлением
/выполнено
/переделала управление через наследование, чтобы было два варианта управления одновременно.

Lesson 2
1.	Расписать в текстовом документе, зачем нужны интерфейсы и их отличие от классов
Интерфейсы нужны для:
1.	реализации множественного наследования
2.	определения поведения в классах наследниках
Отличие интерфейсов от классов:
		Интерфейс							|		Класс
		
Все члены интерфейсов неявно абстрактные 	|	Члены могут быть как абстрактными, так и конкретные с реализацией
Начиная с C# 8.0 реализация методов 		|
 и свойств поддерживается по умолчанию		|

Можно реализовать несколько интерфейсов		|	Может быть унаследован только от одного класса

Члены класса неявно public					|	Члены класса могут быть определены как public, private или protected

Неявно реализованный член интерфейса 		|	Чтобы метод стал запечатанным класс 
по умолчанию является запечатанным			|	должен быть sealed или метод надо пометить как sealed

2.	Расписать в текстовом документе, зачем нужны обобщение и привести несколько примеров их использования
Обобщение - такой способ описания данных и алгоритмов, который позволяет использовать их с различными типами данных.
Обобщения в сравнении с наследованием позволяют повысить безопасность данных, а также сократить количество приведений.
с помощью обощенных методов несколько методов могут быть реализованы одним универсальным способом.
public class Templates<T>
{
    public T _id {get; set; }

    public T GetTemplate()
    {
        return default(T);
    }

    public void AllPrint (T obj)
    {
        Debug.Log(obj);
    }
}
public class FirstLessonExamples : MonoBehaviour
    {
        private void Start()
        {
            var TemplateClassFirst = new Templates<int>();
            var TemplateClassSecond = new Templates<string>();

            TemplateClassFirst.AllPrint(3);
            TemplateClassSecond.AllPrint("test");

            int x = 2;
            int y = 3;

            float a = 1.2f;
            float b = 1.8f;

            Swap<int>(ref x, ref y);
            Swap<float>(ref a, ref b);
        }
        public static void Swap<T>(ref T x, ref T y)
        {
            T t = x;
            T z = y;
            Debug.Log(t);
            Debug.Log(z);
        }
    }
Примеры приложены картинками.

3.	Добавить в игру положительные бонусы, которые необходимо обязательно собрать для победы
/добавила
4.	Добавить в игру положительные бонусы, которые дают различные улучшения (временный прирост скорости, неуязвимость и т.д.)
/добавила
5.	Добавить в игру различные ловушки (моментальная смерть, замедление и т.д.)
/добавила
6.	Реализовать статический импорт класса Debug, где это необходимо
/выполнено
7.	* Реализовать интерфейс ICloneable для клонирование game object
/не делала
8.	* Реализовать интерфейс IDisposable для игрока, ловушек и бонусов
/не делала

Lesson 3
1. По условию, где программа может вести себя неправильно, из-за ошибки гейм и левл дизайнеров, пробросить исключение.
/добавила
2. Расписать в текстовом документе зачем нужно отлавливать исключения и привести примеры.
Исключения нужны, чтобы сообщить геймдизайнеру или программисту о возникновении ошибки в программе, не останавливая ее работу.

Попытка записи в файл, доступный только для чтения
if (!this.logFile.CanWrite)
{
    throw new System.InvalidOperationException("Logfile cannot be read-only");
}

Проверка на ноль
if (Player == null)
{
    throw new NullReferenceException($"Player not found");
}

3. Добавить событие для подбора бонусов и ловушек и подписать нескольких слушателей на это событие, например потряхивать камеру.
/
4. *Задание из пункта 1, только использовать свое исключение
/готово
5. *Задание из пункта 3, только использовать свое событие
/не делала

Lesson 4

1. Добавить кнопку перезапуска уровня
/добавила
2. Добавить экран победы
/добавила
3. *Реализовать разделение на MVC бонусов и ловушек
/добавила только HoleBonus. Остальные делаются по аналогии.

Lesson 5
1. Расписать в текстовом документе плюсы и минусы изученных структур данных и расписать примеры в которых нужно будет использовать тот или иной контейнер

Структуры данных:

List<T>
Список это обертка для более удобной работы с массивом (добавление, удаление объектов, изменения и пр.)
Списки хорошо использовать, когда необходимо поочередно перебирать элементы.
Также плюсом является то, что элементы можно убирать, добавлять из любого места.
Может увеличивать емкость.
Можно применять linq.
Минусом же является не оптимальное использование памяти.
Чтобы найти элемент надо или перебрать все или знать индекс элемента.
Медленнее работает чем массивы.

Использовать его можно, например, при формировании списка объектов на сцене.

LinkedList<T>
Сохраняет элементы в двунаправленном списке.
Может ссылаться на свои элементы.
Можно менять элементы местами.
Позволяет пролистывать список в обе стороны.

HashSet<T> и SortedSet<T>

HashSet<T>
Дает самый быстрый поиск по ключу.
Нельзя использовать несколько одинаковых элементов.
Коллекция не сортируется.
 
SortedSet<T>
Тоже самое, что и HashSet<T>, только элементы упорядочены.
Зная порядок элементов списка можно получить к ним доступ в постоянное время

Занимают больше памяти, но делают более быстрые вычисления.
Дают прирост производительности на больших коллекциях, так как некоторые операции выполняются быстрее

Можно использовать когда нужно перечислить или проверить наличие по ключу.
Если нужно много раз проверять содержится ли элементы в списке.

Если реализовать ignore list при помощи HashSet, мы избавимся от линейного поиска по списку, заменяя его поиском hash-ключа и избавимся от сравнения строк.
Еще пример Оглавление.

ObservableCollection<T>
Коллекция которая позволяет подписываться на событие
Удобен когда необходимо подписаться на события, происходящие с коллекцией

Dictionary<TKey, TValue>
List может хранить не уникальные значения. Ключи в словаре уникальны.
Можно получать доступ ко всем ключам и значениям, извлекать элементы по индексатору типа ключа
Поддерживается сериализация списка
Расширяемый
Указав емкость можно исключить изменение размера словаря во время выполнения, что повысит производительность.

Queue<T>
когда нужно получить первое значение. Первый зашел, первый вышел.

Удобен, когда надо выполнить последовательность действий. 
Например, в стратегиях при постройке юнитов.
Последовательность выполнения квестов для игрока.

Stack<T>
когда надо работать с последним "положенным" значением. Последний зашел, первый вышел.

Удобен, когда надо отменять действия.
Активно применяется в онлайн играх, где обозначает прирост количества однородных предметов или эффектов путем их сложения.
Стек можно использовать когда есть вложенность. Т.е. один предмет вложен в другой.
(Сначала в стек кладем иглу со смертью кощея, потом утку, потом зайца, а потом сундук
а доставать только наоборот сначала сундук, потом - заяца, утку, яйцо, иглу со смертью кощея :) ).
Детская пирамидка стек. Мясо на шампуре :).
Стопка игральных карт тоже стек.

2. Реализовать метод расширения для поиска количества символов в строке
/готово
3. Дана коллекция List<T>. Требуется подсчитать, сколько раз каждый элемент встречается в данной коллекции:
a. для целых чисел;
/готово
b. * для обобщенной коллекции;
/готово
c. ** используя Linq.
/готово
4. * Дан фрагмент программы:
Dictionary<string, int> dict = new Dictionary<string, int>()
{
	{"four",4 },
	{"two",2 },
	{ "one",1 },
	{"three",3 },
};
var d = dict.OrderBy(delegate(KeyValuePair<string,int> pair) { return pair.Value; });
foreach (var pair in d)
{
	Debug.Log($"{pair.Key} - {pair.Value}");
}

а. Свернуть обращение к OrderBy с использованием лямбда-выражения =>.
/готово
b. * Развернуть обращение к OrderBy с использованием делегата 
/готово

Lesson 6

1. Реализовать сохранениие сохранение положительных и отрицательных бонусов на карте.
/сделано
2. Добавить в игру миникарту.
/добавила
3. *Добавить к сохранению данных их шифрование.
/не делала
4. * Реализовать в игре скриншот карты и вставить её под радар
/не делала
5. ** Запустить Coroutine без Monobehaivior.
/cделала статичный класс с корутиной.

Lesson 7
1. Разработать свое окно редактора, добавить в него базовые составляющие интерфейса.
/сделала
2. Реализовать вызов разработанного окна с помощью меню.
/сделала
3. Расширить функционал скрипта в окне инспектора.
/
4. *Реализовать атрибут для получения пути к объекту
/